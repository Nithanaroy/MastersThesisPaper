\section{Related Work to {\rrp}(G, v, R)} \label{sec:relwork}
A naive solution to {\rrp} can be to first find all vertices that fall inside R and then find shortest path to each. To filter vertices that fall inside R a spatial index like a Quad tree or a R-tree can be utilized. Then to find the shortest paths to each such approach can use an algorithm like Dijkstra's ~\cite{S1990} or Bellman Ford~\cite{R1956}. The paper~\cite{NSD2013} provides a distributed framework for this decoupled approach. They reduce a socio-spatial problem into smaller sub-problems and implement them as distributed functions.

Another idea is to combine the socio-spatial predicates for better pruning and paper~\cite{KJY+2015} proposes an idea where they prune the graph in a round robin manner by social and spatial distance functions. Using this algorithm we can answer queries like my friends who are socially and spatially closer to me.

{A lot of research has happened to answer reachability queries ranging from O($n^3$}{) memory intensive transitive closure algorithms to O($m \times n$) time intensive DFS and BFS algorithms. Approaches like GRAIL~\cite{YCZ+2010}, 2HOP~\cite{CHK+2003}, GRIPP~\cite{SU2007}, Dual Labeling~\cite{HHJ+2006} find a sweet spot between the two extremes to answer reachability and path queries. Here we are trying to find a pattern between a vertex and a spatial predicate region simultaneously and not between two vertices nor a path queries. }

There are several spatial indices~\cite{PMA2001,H2006,SS2003} that quickly filter a graph based on our spatial region. Some of them divide the space equally and some based on data. They recursively do this approach to construct a tree. This heavily improves the search speed as they prune a significant portion at every level as traversing the tree. However, we can either create a tree for spatial vertices or for social vertices but not for both using ideas from these papers.

{The paper GeoReach~\cite{YM2016} gives an idea how to answer reachability queries with spatial predicate. They create an index with three types of vertices - B vertex, G vertex, R vertex with increasing degree of information about reachability to a region. The query returns true if a vertex can reach a region, else false. However, entire path to a region is crucial and not just true or false.}
